# EDA Projeto BMSSP para SSSP
  Implementação, documentação e experimentação do **Bounded Multi-Source Shortest Path** (**BMSSP**) como algoritmo que resolve o problema de **Single Source Shortest Path** (**SSSP**) em comparação com **Dijkstra**.

  Esse repositório utiliza o artigo [Breaking the Sorting Barrier for Directed Single-Source Shortest Paths](https://arxiv.org/abs/2504.17033) como base para implementar e documentar o **BMSSP** resolvendo o problema de menor caminho para uma única fonte. Além disso, é feita uma comparação experimental com **Dijkstra**, a fim de analisar a superação da barreira de tempo para **SSSP** prometida.

## ANÁLISE PRIMÁRIA
  Algoritmos de menor caminho identificam o caminho mais curto entre pontos em um grafo. O caminho mais curto se refere à soma dos pesos das arestas (custo, tempo ou distância). Essa questão é de suma importância para diversas aplicações, e a eficiência com que o menor caminho é encontrado é crucial para o bom funcionamento de redes de fluxos,  as quais se aplicam à logística de transportes de produtos, à escolha de rotas em redes digitais e aos algoritmos de recomendação de redes sociais. O recém-lançado **BMSSP** é um algoritmo para identificar os caminho mais curtos para fonte única que quebra a barreira de tempo de **Dijkstra**, e a falta de implementações e documentações sobre ele motivaram esse estudo. Para essa análise, o grupo implementou o programa em Java, documentou seu funcionamento e realizou testes de comparação de eficiência com o algoritmo de menor caminho de **Dijkstra**. 

## BMSSP
  A busca pelos menores caminho de fonte única em grafos direcionados com pesos não negativos é um problema central na ciência da computação. Nesse contexto, o algoritmo de **Dijkstra** consolidou-se como o método padrão para resolver o problema de caminho mínimo a partir de uma única fonte, devido à sua eficiência. 
  O algoritmo já tradicional de **Dijkstra** possui uma complexidade de tempo $O(m\log n)$, sendo **n** o número de nós e **m** o número de arestas, o que era considerado a barreira para esse tipo de problema. O artigo **Breaking the Sorting Barrier for Directed Single-Source Shortest Paths** introduz um novo algoritmo teórico com complexidade de tempo $O(m\log^{2/3}n)$, quebrando essa barreira. No entanto, a ausência de implementações concretas e documentadas desse algoritmo dificulta sua compreensão e análise prática, limitando o acesso ao conteúdo por parte da comunidade acadêmica e técnica.
  Diante disso, este projeto tem como objetivo realizar a implementação do algoritmo proposto no artigo referenciado, seguindo sua lógica, suas estruturas de dados e suas estratégias de otimização de forma fidedigna. Para isso, o código será feito com Java, utilizando otimizações de implementação e da linguagem quando possível, sem alterar sua complexidade, permitindo a validação de seu funcionamento. Além disso, são realizados testes comparativos entre os algoritmos, utilizando grafos esparsos, já que a diferença de complexidade é mais proeminente com **m** pequeno, e com graus parecidos entre os nós, já que o artigo assume essa configuração que se satisfaça a complexidade.

  O processo de execução do projeto ocorreu por meio da divisão de tarefas dentro de subgrupos do projeto, com reuniões semanais (sprints) e a especificação dos problemas/soluções para o código. Todas as ferramentas para essa produção acadêmica se deram de maneira consensual entre os participantes, a partir de discussões sobre a revisão do desempenho e da dificuldade no cumprimento das especificações do algoritmo de menor caminho.
  Nesse viés, esse projeto foi ramificado em 4 partes práticas e 2 partes de análise e conclusão, sendo cada uma focada em uma tarefa ou funcionalidade específica. Dentre os  objetivos principais do plano de execução do BMSSP, temos, em ordem de implementação no projeto, o/a: 
  1. #### Prática
      A implementação propriamente dita do algoritmo, seguindo a mesma divisão do artigo em métodos, além da estrutura auxiliar especializada definida para o funcionamento.
        - DQueue()
        - findPivots()
        - baseCase()
        - bmssp()
  2. #### Análise
      Experimentação do **BMSSP** em comparação com **Dijkstra** para verificação de corretude e para análise gráfica dos tempos de execução.
        - Comparação dos resultados dos algoritmos para comprovar a corretude do algoritmo. 
        - Plotagem de gráficos para o tempo de execução tanto para o **BMSSP** quanto para o algoritmo de **Dijkstra** para a análise de eficiência.

  Primeiramente, foram definidas as estruturas iniciais de grafos e as estruturas de dados que seriam usadas para implementar as abstrações do artigo. Depois, foi realizada a implementação das funções separadamente. Essa etapa foi dividida entre os integrantes, que se organizaram de maneira a cada um ficar com uma parte da estrutura, auxiliando na otimização do projeto. 
  Por fim, foi executada uma bateria de testes com o intuito de verificar se o **BMSSP** resolve corretamente os problemas de tamanhos variados e de analisar o tempo de execução, com a plotagem dos gráficos de comparação para a visualização da complexidade de tempo.

## Implementação

  A implementação do algoritmo é dividida em três métodos principais, o `bmssp`, o `baseCase` e o `findPivots`. O `bmssp` é o método que faz uso dos outros dois métodos e controla a recursão principal do algoritmo, sendo responsável por dividir o problema central em problemas menores até que o caso base seja alcançado, ou seja, o nível da recursão seja igual a zero. Em cada chamada recursiva, esse método reduz o limite superior de distância (upper bound) para que ele seja igual a distância até o pivô mais próximo encontrado pelo Find Pivots. Além disso, as distâncias para todos os pivôs encontrados são inseridas na DQueue, uma fila adaptada que permite, com uma única consulta, retornar os M menores elementos armazenados de forma eficiente. No laço principal, ele acessa os M menores elementos da DQueue e executa recursivamente o BMSSP, passando como parâmetro o nível de recursão atual decrementado em uma unidade e os M menores elementos acessados. Ao final, ele verifica se as novas distâncias encontradas no nível inferior da recursão são, de fato, as menores até o momento, uma vez que as novas distâncias encontradas podem ser maiores do que as que já estavam armazenadas. Assim, após as menores distâncias encontradas serem armazenadas, o novo upper bound calculado e os novos nós completados na recursão atual são retornados. Isso se repete até que o nível de recursão seja igual a zero. 
  
  Assim, quando o nível é zero, o _**Base Case**_ é executado, calculando as distâncias para uma quantidade limitada de nós com base no nó pivô passado como parâmetro e em um upper bound que, nesse caso, é a distância até o pivô em questão. Dessa forma, enquanto o número máximo de nós e iterações não for atingido, esse método calcula a distância para todos os nós ligados ao pivô e, na próxima iteração, calcula a distância para os nós ligados aos novos nós encontrados e assim sucessivamente. 
  
  O _**Find Pivots**_, por sua vez, é o método responsável por encontrar os nós pivôs que serão usados para particionar o problema e reduzir o nível de recursão até que ele seja zero. Enquanto o número de iterações e o número de nós completados não atingir o limite máximo, esse método permanece calculando a menor distância até os nós da fronteira (border). Ao final, se o número de nós completos for maior que o limite definido, toda a fronteira de nós é retornada, caso contrário, o método busca por nós que formam uma árvore no grafo e retorna os nós raízes dessas árvores. 
  
  Por fim, foi implementado o método _**solve**_, que recebe o nó de origem e o grafo onde o algoritmo implementado irá operar. Esse método inicializa as estruturas de dados iniciais, define as distâncias para cada nó com um valor infinito e executa o método BMSSP. 

## Considerações finais
  O presente trabalho dedicou-se à análise de algoritmos de menor caminho, cuja relevância se estende por múltiplas aplicações práticas, desde a otimização de rotas em sistemas de GPS para logística de transportes até o roteamento de pacotes em redes de computadores e o estabelecimento de conexões em telecomunicações. Tais aplicações, que demandam o processamento de um volume crescente de dados, impulsionam a busca por soluções computacionais cada vez mais eficientes. Nesse contexto, algoritmos clássicos como o de Dijkstra têm sido amplamente implementados, estabelecendo um padrão de eficiência com uma complexidade temporal de O(m log n), onde 'm' e 'n' representam, respectivamente, o número de arestas e de vértices do grafo. 
  
  Contudo, este projeto focou na análise de uma alternativa mais recente e performática: o algoritmo BMSSP (Bounded Multiple-Source Shortest Path), proposto por Duan et al.¹O estudo aprofundado do BMSSP revelou seu potencial teórico, com uma complexidade assintótica de O(m log²/³n), que representa um avanço sobre as abordagens anteriores. A fase prática deste trabalho consistiu na implementação do referido algoritmo para a solução do problema do caminho mínimo de fonte única (Single Source Shortest Path - SSSP). A partir da execução de testes comparativos em relação ao algoritmo de Dijkstra, foi possível validar empiricamente a eficácia superior do BMSSP em cenários que necessitam de tratamento de dados em larga escala. 
  
  Portanto, conclui-se que o algoritmo BMSSP não apenas otimiza a resolução de problemas de menor caminho, mas também se apresenta como uma alternativa congruente e eficiente para futuras aplicações acadêmicas e de mercado que exijam alto desempenho no processamento de grafos.

